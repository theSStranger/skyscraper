'(0 1 2)
'(0 1 3)
'(0 2 1)
'(0 2 3)
'(0 3 1)
'(0 3 2)
'(1 0 2)
'(1 0 3)
'(1 2 0)
'(1 2 3)
'(1 3 0)
'(1 3 2)
'(2 0 1)
'(2 0 3)
'(2 1 0)
'(2 1 3)
'(2 3 0)
'(2 3 1)
'(3 0 1)
'(3 0 2)
'(3 1 0)
'(3 1 2)
'(3 2 0)
'(3 2 1)


Write a Racket program that creates permutations of 3 numbers selected from [0, 1, 2, 3], but does not contain reversed copies of any combination. Example: if (3,0,1) is present, it should exclude (1,0,3). If (1, 2, 3) is present, it should exclude (3,2,1)
GPT Responded:
(define (permutations-no-reversed-copies lst)
  (cond
    [(null? lst) empty]
    [(null? (cdr lst)) lst]
    [else
     (let ([head (car lst)]
           [tail (cdr lst)])
       (append (map (lambda (x) (cons head x))
                    (permutations-no-reversed-copies tail))
               (permutations-no-reversed-copies tail)))]))

(permutations-no-reversed-copies '(0 1 2 3))
;; Result: '((0 1 2) (0 1 3) (0 2 1) (0 2 3) (0 3 1) (0 3 2) (1 0 2) (1 0 3) (1 2 0) (1 2 3) (1 3 0) (1 3 2) (2 0 1) (2 0 3) (2 1 0) (2 1 3) (2 3 0) (2 3 1) (3 0 1) (3 0 2) (3 1 0) (3 1 2) (3 2 0) (3 2 1))

Modify the above code so it includes only one copy of every mirrored pair
GPT Responded:
of permutations.

(define (permutations-no-reversed-copies lst)
  (cond
    [(null? lst) empty]
    [(null? (cdr lst)) lst]
    [else
     (let ([head (car lst)]
           [tail (cdr lst)])
       (append (map (lambda (x) (cons head x))
                    (filter (lambda (x) (not (equal? (reverse x) x)))
                            (permutations-no-reversed-copies tail)))
               (permutations-no-reversed-copies tail)))]))

(permutations-no-reversed-copies '(0 1 2 3))
;; Result: '((0 1 2) (0 1 3) (0 2 1) (0 2 3) (0 3 1) (1 0 2) (1 0 3) (1 2 0) (1 2 3) (1 3 0) (2 0 1) (2 0 3) (2 1 0) (2 1 3) (2 3 0) (3 0 1) (3 0 2) (3 1 0) (3 1 2))
